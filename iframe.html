<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
  <script>
    const urlParams = new URLSearchParams(window.location.search);
    const isFullscreen = urlParams.get('fullscreen') === 'true';
    const isShorts = urlParams.get('isShorts') === 'true';

    let containerStyle = '';
    if (isFullscreen) {
      containerStyle =
        'position: fixed; top: 0; left: 0; width: 100%; height: 100%; padding-bottom: 0;';
    }
  </script>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
    }

    .container {
      position: relative;
      width: 100%;
      height: 0;
      padding-bottom: 56.25%;
      background-color: green;
    }

    .video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: blue;
    }

    .error-message {
      color: red;
      padding: 10px;
      background-color: #ffe0e0;
      margin: 10px 0;
    }
    .debug-info {
      padding: 10px;
      background-color: #e0ffe0;
      color: green;
      font-family: monospace;
      white-space: pre-wrap;
      word-break: break-all;
    }

    .container.shorts {
      padding-bottom: 177.78%; /* 9:16 aspect ratio for vertical videos */
    }
  </style>
</head>

<body>
  <div id="debug-container"></div>
  <div id="error-container"></div>
  <div id="video-container" class="hidden">
    <div class="container" id="container">
      <div class="video" id="player"></div>
    </div>
  </div>

  <script>
    function showDebugInfo(message) {
      const debugContainer = document.getElementById('debug-container');
      const debugElement = document.createElement('div');
      debugElement.className = 'debug-info';
      debugElement.textContent = message;
      debugContainer.appendChild(debugElement);
    }

    function showError(message) {
      const errorContainer = document.getElementById('error-container');
      const errorElement = document.createElement('div');
      errorElement.className = 'error-message';
      errorElement.textContent = message;
      errorContainer.appendChild(errorElement);
    }

    try {
      const fullUrl = window.location.href;
      showDebugInfo('Full URL:\n' + fullUrl);
      
      // Parse URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      const allParams = {};
      for (const [key, value] of urlParams) {
        allParams[key] = value;
      }
      showDebugInfo('All URL parameters:\n' + JSON.stringify(allParams, null, 2));

      // Handle the case with two question marks
      const parts = fullUrl.split('?');
      const lastPart = parts[parts.length - 1];
      const dataParam = lastPart.startsWith('data=') ? lastPart : null;

      let UrlQueryData;
      if (dataParam) {
        UrlQueryData = decodeURIComponent(dataParam.slice(5)); // Remove 'data=' prefix and decode
      } else {
        // If not found with two question marks, try normal URL parsing
        const parsedUrl = new URL(fullUrl);
        const urlParams = new URLSearchParams(parsedUrl.search);
        UrlQueryData = urlParams.get('data');
        
        if (!UrlQueryData) {
          showError('Debug: All URL parameters: ' + parsedUrl.search);
          throw new Error('No data parameter found in URL');
        }
        UrlQueryData = decodeURIComponent(UrlQueryData); // Decode the URL-encoded data
      }
      
      showError('Debug: Data parameter value: ' + UrlQueryData);

      let parsedData;
      try {
        parsedData = JSON.parse(UrlQueryData);
      } catch (jsonError) {
        throw new Error(`Failed to parse JSON data: ${jsonError.message}`);
      }
      
      if (!parsedData || typeof parsedData !== 'object') {
        throw new Error('Parsed data is not a valid object');
      }

      showError('Debug: Parsed data: ' + JSON.stringify(parsedData, null, 2));

      const {
        end,
        list,
        color,
        start,
        rel_s,
        loop_s,
        listType,
        playerLang,
        playlist,
        videoId_s,
        controls_s,
        cc_lang_pref_s,
        contentScale_s,
        allowWebViewZoom,
        modestbranding_s,
        iv_load_policy,
        preventFullScreen_s,
        showClosedCaptions_s,
      } = parsedData;

      // Check if required properties are present
      if (!videoId_s) {
        throw new Error('videoId_s is required but not provided in the data');
      }

      function sendMessageToRN(msg) {
        if (window.ReactNativeWebView && window.ReactNativeWebView.postMessage) {
          window.ReactNativeWebView.postMessage(JSON.stringify(msg));
        } else {
          showError('ReactNativeWebView not available for sending messages');
        }
      }

      let metaString = '';
      if (contentScale_s) {
        metaString += `initial-scale=${contentScale_s}, `;
      }
      if (!allowWebViewZoom) {
        metaString += `maximum-scale=${contentScale_s}`;
      }

      const viewport = document.querySelector('meta[name=viewport]');
      viewport.setAttribute('content', 'width=device-width, ' + metaString);

      var tag = document.createElement('script');
      tag.src = 'https://www.youtube.com/iframe_api';
      var firstScriptTag = document.getElementsByTagName('script')[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

      var player;
      function onYouTubeIframeAPIReady() {
        const containerElement = document.querySelector('.container');
        if (isShorts) {
          containerElement.classList.add('shorts');
        }
        const containerWidth = containerElement.clientWidth;
        const containerHeight = containerElement.clientHeight;

        // Define a fixed player ID
        const playerId = 'player';

        const playerVars = {
          end: end,
          rel: rel_s,
          list: list,
          color: color,
          loop: loop_s,
          start: start,
          playsinline: 1,
          hl: playerLang,
          playlist: playlist,
          listType: listType,
          controls: controls_s,
          fs: preventFullScreen_s,
          cc_lang_pref: cc_lang_pref_s,
          iv_load_policy: iv_load_policy,
          modestbranding: modestbranding_s,
          cc_load_policy: showClosedCaptions_s,
        };

        // Add shorts-specific parameters
        if (isShorts) {
          playerVars.loop = 1; // Always loop shorts
          playerVars.playlist = videoId_s; // Required for looping a single video
        }

        player = new YT.Player(playerId, {
          width: containerWidth,
          height: containerHeight,
          videoId: videoId_s,
          playerVars: playerVars,
          events: {
            onReady: onPlayerReady,
            onError: onPlayerError,
            onStateChange: onPlayerStateChange,
            onPlaybackRateChange: onPlaybackRateChange,
            onPlaybackQualityChange: onPlaybackQualityChange,
          },
        });
      }

      function onPlayerError(event) {
        let errorMessage = 'An error occurred';
        switch (event.data) {
          case 2:
            errorMessage = 'Invalid parameter';
            break;
          case 5:
            errorMessage = 'HTML5 player error';
            break;
          case 100:
            errorMessage = 'Video not found or removed';
            break;
          case 101:
          case 150:
            errorMessage = 'Video playback not allowed';
            break;
        }
        if (isShorts) {
          errorMessage += ' (Shorts format)';
        }
        sendMessageToRN({ eventType: 'playerError', data: event.data, message: errorMessage });
      }

      function onPlaybackRateChange(event) {
        sendMessageToRN({ eventType: 'playbackRateChange', data: event.data });
      }

      function onPlaybackQualityChange(event) {
        sendMessageToRN({ eventType: 'playerQualityChange', data: event.data });
      }

      function onPlayerReady(event) {
        sendMessageToRN({ eventType: 'playerReady' });
      }

      function onPlayerStateChange(event) {
        sendMessageToRN({ eventType: 'playerStateChange', data: event.data });
      }

      var isFullScreen = false;
      function onFullScreenChange() {
        isFullScreen =
          document.fullscreenElement ||
          document.msFullscreenElement ||
          document.mozFullScreenElement ||
          document.webkitFullscreenElement;

        sendMessageToRN({
          eventType: 'fullScreenChange',
          data: Boolean(isFullScreen),
        });
      }

      document.addEventListener('fullscreenchange', onFullScreenChange);
      document.addEventListener('msfullscreenchange', onFullScreenChange);
      document.addEventListener('mozfullscreenchange', onFullScreenChange);
      document.addEventListener('webkitfullscreenchange', onFullScreenChange);

      window.addEventListener('message', function (event) {
        const { data } = event;

        try {
          const parsedData = JSON.parse(data);
          const { eventName, meta } = parsedData;

          switch (eventName) {
            case 'playVideo':
              player.playVideo();
              break;

            case 'pauseVideo':
              player.pauseVideo();
              break;

            case 'muteVideo':
              player.mute();
              break;

            case 'unMuteVideo':
              player.unMute();
              break;

            case 'setVolume':
              player.setVolume(meta.volume);
              break;

            case 'setPlaybackRate':
              player.setPlaybackRate(meta.playbackRate);
              break;
          }
        } catch (error) {
          console.error('Error parsing data', event, error);
        }
      });
    } catch (error) {
      showError('Error initializing player: ' + error.message);
      console.error('Detailed error:', error);
    }
  </script>
</body>

</html>
